---
---

<section class="game">
  <div class="game__header">
    <h1 class="game__title">2048</h1>
    <div class="game__scores">
      <div class="game__score">
        <div class="game__score-title">SCORE</div>
        <div class="game__score-value">0</div>
      </div>
    </div>
  </div>
  
  <div class="game__explanation">
    <p>Join the numbers and get to the <strong>2048 tile!</strong></p>
  </div>
  
  <div class="game__board">
    <div class="game__board-row" id="row-0">
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
    </div>
    <div class="game__board-row" id="row-1">
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
    </div>
    <div class="game__board-row" id="row-2">
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
    </div>
    <div class="game__board-row" id="row-3">
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
      <div class="game__cell"></div>
    </div>
  </div>
  
  <div class="game__explanation">
    <p><strong>HOW TO PLAY:</strong> Use your <strong>arrow keys</strong> to move the tiles. When two tiles with the same number touch, they <strong>merge into one!</strong></p>
  </div>
  
  <button class="game__restart-button">New Game</button>
</section>

<style>
  /* Import the modernized tile styles */
  @import '../styles/tiles.css';
  
  .game {
    width: 500px;
    margin: 0 auto;
    padding: 20px;
    font-family: var(--font-family-primary);
  }
  
  .game__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
  }
  
  .game__title {
    font-size: 80px;
    font-weight: bold;
    margin: 0;
    color: var(--color-text-dark);
  }
  
  .game__scores {
    display: flex;
    gap: 10px;
  }
  
  .game__score {
    background: var(--color-board);
    padding: 10px 15px;
    border-radius: 8px;
    text-align: center;
    min-width: 100px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
  }
  
  .game__score-title {
    font-size: 14px;
    font-weight: bold;
    color: var(--color-tile-2);
    text-transform: uppercase;
  }
  
  .game__score-value {
    font-size: 24px;
    font-weight: bold;
    color: var(--color-text-light);
  }
  
  .game__explanation {
    margin-bottom: 20px;
    color: var(--color-text-dark);
  }
  
  .game__board {
    background: var(--color-board);
    border-radius: 8px;
    padding: 10px;
    position: relative;
    outline: none;
    cursor: pointer;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
  }
  
  .game__board-row {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
  }
  
  .game__board-row:last-child {
    margin-bottom: 0;
  }
  
  .game__cell {
    width: 100px;
    height: 100px;
    background: var(--color-cell-empty);
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    color: var(--color-text-dark);
  }
  
  .game__restart-button {
    background: var(--color-button-bg);
    color: var(--color-button-text);
    border: none;
    border-radius: 8px;
    padding: 10px 20px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    margin-top: 20px;
    transition: background 0.2s;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
  }
  
  .game__restart-button:hover {
    background: var(--color-button-bg-hover);
    transform: translateY(-1px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
  }
  
  .game__board:focus {
    outline: none;
    box-shadow: 0 0 0 3px var(--color-accent-primary);
  }
  
  .game__message {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(238, 228, 218, 0.73);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    border-radius: 8px;
    font-size: 40px;
    font-weight: bold;
    color: var(--color-text-dark);
    backdrop-filter: blur(3px);
  }
  
  .game__message p {
    margin: 0 0 20px;
  }
  
  .game__try-again-button {
    background: var(--color-button-bg);
    color: var(--color-button-text);
    border: none;
    border-radius: 8px;
    padding: 10px 20px;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
  }
  
  .game__try-again-button:hover {
    background: var(--color-button-bg-hover);
    transform: translateY(-1px);
    box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
  }
  
  .game__message--game-over {
    background: rgba(238, 228, 218, 0.73);
  }
  
  .game__message--game-won {
    background: rgba(237, 194, 46, 0.5);
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .game {
      width: min(500px, 90vw);
    }
    
    .game__title {
      font-size: 60px;
    }
    
    .game__cell {
      width: calc((90vw - 60px) / 4);
      height: calc((90vw - 60px) / 4);
      max-width: 100px;
      max-height: 100px;
    }
  }
  
  @media (max-width: 480px) {
    .game__title {
      font-size: 48px;
    }
    
    .game__score {
      min-width: 80px;
    }
    
    .game__board {
      padding: 8px;
    }
    
    .game__board-row {
      gap: 8px;
      margin-bottom: 8px;
    }
  }
</style>

<script>
  // Game state
  let board = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
  ];
  
  let previousBoard: number[][] = [];
  let score = 0;
  let gameOver = false;
  let win = false;
  let isMoving = false; // Debounce flag to prevent input during animations
  
  // DOM elements
  const scoreElement = document.querySelector('.game__score-value');
  const boardElement = document.querySelector('.game__board');
  
  // Helper function to deep copy the board
  function copyBoard(src: number[][]) {
    return src.map(row => [...row]);
  }
  
  // Update board display with animations
  function updateDisplay(animate = false) {
    // Update score
    if (scoreElement) {
      scoreElement.textContent = score.toString();
    }
    
    // Clear all animation classes first
    const allCells = document.querySelectorAll('.game__cell');
    allCells.forEach(cell => {
      cell.classList.remove('game__cell--new', 'game__cell--merged', 
                           'game__cell--slide-left', 'game__cell--slide-right',
                           'game__cell--slide-up', 'game__cell--slide-down');
    });
    
    // Update board cells
    const rows = document.querySelectorAll('.game__board-row');
    rows.forEach((row, rowIndex) => {
      const cells = row.querySelectorAll('.game__cell');
      cells.forEach((cell, colIndex) => {
        const value = board[rowIndex][colIndex];
        const prevValue = previousBoard[rowIndex] ? previousBoard[rowIndex][colIndex] : 0;
        
        // Update cell content and classes
        cell.textContent = value !== 0 ? value.toString() : '';
        cell.className = `game__cell ${value !== 0 ? `game__cell-${value}` : ''}`;
        
        // Add animation classes if animating
        if (animate && value !== 0) {
          // Check if this is a new tile
          if (prevValue === 0 && value !== 0) {
            cell.classList.add('game__cell--new');
          }
          // Check if this tile was merged
          else if (value > prevValue && prevValue !== 0) {
            cell.classList.add('game__cell--merged');
          }
        }
      });
    });
    
    // Show game over or win message
    let gameMessage = document.querySelector('.game__message');
    if (gameMessage) {
      gameMessage.remove();
    }
    
    if (gameOver && boardElement) {
      gameMessage = document.createElement('div');
      gameMessage.className = 'game__message game__message--game-over';
      gameMessage.innerHTML = `
        <p>Game Over!</p>
        <button class="game__try-again-button">Try Again</button>
      `;
      boardElement.appendChild(gameMessage);
      const tryAgainButton = gameMessage.querySelector('.game__try-again-button');
      if (tryAgainButton) {
        tryAgainButton.addEventListener('click', initializeGame);
      }
    } else if (win && !document.querySelector('.game__message--game-won') && boardElement) {
      gameMessage = document.createElement('div');
      gameMessage.className = 'game__message game__message--game-won';
      gameMessage.innerHTML = `
        <p>You Win!</p>
        <button class="game__try-again-button">Play Again</button>
      `;
      boardElement.appendChild(gameMessage);
      const playAgainButton = gameMessage.querySelector('.game__try-again-button');
      if (playAgainButton) {
        playAgainButton.addEventListener('click', initializeGame);
      }
    }
  }
  
  function initializeGame() {
    // Initialize board
    board = [
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ];
    
    previousBoard = copyBoard(board);
    
    // Add two initial tiles
    addRandomTile();
    addRandomTile();
    
    score = 0;
    gameOver = false;
    win = false;
    isMoving = false;
    
    updateDisplay(false);
  }
  
  function addRandomTile() {
    // Find all empty cells
    const emptyCells = [];
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        if (board[i][j] === 0) {
          emptyCells.push({ row: i, col: j });
        }
      }
    }
    
    // Add 2 or 4 to a random empty cell
    if (emptyCells.length > 0) {
      const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
      board[randomCell.row][randomCell.col] = Math.random() < 0.9 ? 2 : 4;
    }
  }
  
  // Apply slide animation based on direction
  function applySlideAnimation(direction: string) {
    const rows = document.querySelectorAll('.game__board-row');
    rows.forEach((row, rowIndex) => {
      const cells = row.querySelectorAll('.game__cell');
      cells.forEach((cell, colIndex) => {
        if (board[rowIndex][colIndex] !== 0) {
          // Check if tile moved
          if (previousBoard[rowIndex][colIndex] !== 0 && 
              board[rowIndex][colIndex] === previousBoard[rowIndex][colIndex]) {
            // Tile moved, apply appropriate animation
            cell.classList.add(`game__cell--slide-${direction}`);
          }
        }
      });
    });
  }
  
  // Move tiles logic
  function moveLeft() {
    let moved = false;
    const newBoard = copyBoard(board);
    
    for (let i = 0; i < 4; i++) {
      let row = board[i].filter(val => val !== 0);
      
      // Merge tiles
      for (let j = 0; j < row.length - 1; j++) {
        if (row[j] === row[j + 1]) {
          row[j] *= 2;
          score += row[j];
          row[j + 1] = 0;
          
          // Check for 2048
          if (row[j] === 2048 && !win) {
            win = true;
          }
        }
      }
      
      // Remove zeros and pad with zeros
      row = row.filter(val => val !== 0);
      while (row.length < 4) {
        row.push(0);
      }
      
      // Check if row changed
      for (let j = 0; j < 4; j++) {
        if (board[i][j] !== row[j]) {
          moved = true;
        }
        newBoard[i][j] = row[j];
      }
    }
    
    if (moved) {
      previousBoard = copyBoard(board);
      board = newBoard;
    }
    
    return moved;
  }
  
  function moveRight() {
    let moved = false;
    const newBoard = copyBoard(board);
    
    for (let i = 0; i < 4; i++) {
      let row = board[i].filter(val => val !== 0);
      
      // Merge tiles from right
      for (let j = row.length - 1; j > 0; j--) {
        if (row[j] === row[j - 1]) {
          row[j] *= 2;
          score += row[j];
          row[j - 1] = 0;
          
          // Check for 2048
          if (row[j] === 2048 && !win) {
            win = true;
          }
        }
      }
      
      // Remove zeros and pad with zeros
      row = row.filter(val => val !== 0);
      while (row.length < 4) {
        row.unshift(0);
      }
      
      // Check if row changed
      for (let j = 0; j < 4; j++) {
        if (board[i][j] !== row[j]) {
          moved = true;
        }
        newBoard[i][j] = row[j];
      }
    }
    
    if (moved) {
      previousBoard = copyBoard(board);
      board = newBoard;
    }
    
    return moved;
  }
  
  function moveUp() {
    let moved = false;
    const newBoard = copyBoard(board);
    
    for (let j = 0; j < 4; j++) {
      let col = [];
      for (let i = 0; i < 4; i++) {
        if (board[i][j] !== 0) {
          col.push(board[i][j]);
        }
      }
      
      // Merge tiles
      for (let i = 0; i < col.length - 1; i++) {
        if (col[i] === col[i + 1]) {
          col[i] *= 2;
          score += col[i];
          col[i + 1] = 0;
          
          // Check for 2048
          if (col[i] === 2048 && !win) {
            win = true;
          }
        }
      }
      
      // Remove zeros and pad with zeros
      col = col.filter(val => val !== 0);
      while (col.length < 4) {
        col.push(0);
      }
      
      // Check if column changed
      for (let i = 0; i < 4; i++) {
        if (board[i][j] !== col[i]) {
          moved = true;
        }
        newBoard[i][j] = col[i];
      }
    }
    
    if (moved) {
      previousBoard = copyBoard(board);
      board = newBoard;
    }
    
    return moved;
  }
  
  function moveDown() {
    let moved = false;
    const newBoard = copyBoard(board);
    
    for (let j = 0; j < 4; j++) {
      let col = [];
      for (let i = 0; i < 4; i++) {
        if (board[i][j] !== 0) {
          col.push(board[i][j]);
        }
      }
      
      // Merge tiles from bottom
      for (let i = col.length - 1; i > 0; i--) {
        if (col[i] === col[i - 1]) {
          col[i] *= 2;
          score += col[i];
          col[i - 1] = 0;
          
          // Check for 2048
          if (col[i] === 2048 && !win) {
            win = true;
          }
        }
      }
      
      // Remove zeros and pad with zeros
      col = col.filter(val => val !== 0);
      while (col.length < 4) {
        col.unshift(0);
      }
      
      // Check if column changed
      for (let i = 0; i < 4; i++) {
        if (board[i][j] !== col[i]) {
          moved = true;
        }
        newBoard[i][j] = col[i];
      }
    }
    
    if (moved) {
      previousBoard = copyBoard(board);
      board = newBoard;
    }
    
    return moved;
  }
  
  // Check if game is over
  function isGameOver() {
    // Check for empty cells
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 4; j++) {
        if (board[i][j] === 0) {
          return false;
        }
      }
    }
    
    // Check for possible merges
    for (let i = 0; i < 4; i++) {
      for (let j = 0; j < 3; j++) {
        if (board[i][j] === board[i][j + 1]) {
          return false;
        }
      }
    }
    
    for (let j = 0; j < 4; j++) {
      for (let i = 0; i < 3; i++) {
        if (board[i][j] === board[i + 1][j]) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  // Handle keyboard input
  function handleKeyDown(event: KeyboardEvent) {
    if (gameOver || isMoving) return;
    
    let moved = false;
    let direction = '';
    
    switch (event.key) {
      case 'ArrowLeft':
        event.preventDefault();
        moved = moveLeft();
        direction = 'left';
        break;
      case 'ArrowRight':
        event.preventDefault();
        moved = moveRight();
        direction = 'right';
        break;
      case 'ArrowUp':
        event.preventDefault();
        moved = moveUp();
        direction = 'up';
        break;
      case 'ArrowDown':
        event.preventDefault();
        moved = moveDown();
        direction = 'down';
        break;
      default:
        return;
    }
    
    // If tiles moved, animate and add new tile
    if (moved) {
      isMoving = true;
      
      // First update display to show movement
      updateDisplay(false);
      applySlideAnimation(direction);
      
      // After slide animation, add new tile
      setTimeout(() => {
        addRandomTile();
        gameOver = isGameOver();
        updateDisplay(true); // Show new tile with animation
        
        // Re-enable input after all animations complete
        setTimeout(() => {
          isMoving = false;
        }, 200);
      }, 120); // Wait for slide animation to complete
    }
  }
  
  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    // Add keyboard event listener
    document.addEventListener('keydown', handleKeyDown);
    
    // Make board focusable
    if (boardElement) {
      boardElement.setAttribute('tabindex', '0');
      (boardElement as HTMLElement).focus();
    }
    
    // Add restart button event
    const restartButton = document.querySelector('.game__restart-button');
    if (restartButton) {
      restartButton.addEventListener('click', initializeGame);
    }
    
    // Initialize game
    initializeGame();
  });
</script>
